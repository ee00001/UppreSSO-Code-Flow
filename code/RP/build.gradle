
buildscript {
    repositories {
        maven { url 'https://maven.aliyun.com/repository/public' }
        maven { url 'https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk15to18' }
        mavenCentral()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE")
    }
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'org.springframework.boot'
apply plugin: 'io.spring.dependency-management'


    bootJar {
    baseName = 'gs-spring-boot'
    version =  '0.1.0'
}

repositories {

    mavenCentral()

}

sourceCompatibility = 1.8
targetCompatibility = 1.8

dependencies {
    compile("org.springframework.boot:spring-boot-starter-web")
    implementation 'com.google.code.gson:gson:2.10.1'
    implementation 'com.auth0:java-jwt:3.8.1'
//    compile("org.springframework.session:spring-session:1.3.0.RELEASE")
    compile 'commons-codec:commons-codec:1.14'
//    compile 'org.thymeleaf:thymeleaf-spring5:3.0.9.RELEASE'
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.json:json:20231013'
    // OHTTP's HPKE
    implementation("org.bouncycastle:bcprov-jdk15to18:1.82")
    // test
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'
}

test {
    useJUnitPlatform()
}

import java.net.*
import java.nio.file.*
import java.nio.charset.Charset

/** === 可调参数 === **/
def SIDECAR_PORT = System.getenv('SIDECAR_PORT') ?: '9797'
def ROOT_DIR       = rootProject.projectDir
def SIDECAR_DIR    = new File(ROOT_DIR, "../sidecar")
def SIDECAR_SCRIPT = new File(SIDECAR_DIR, "dist/sidecar.cjs").absolutePath
// 如需指定 node 绝对路径，改这里
def NODE_CMD = 'node'
def HEALTH_URL = "http://127.0.0.1:${SIDECAR_PORT}/health"

/** === 日志与 PID 文件 === **/
def OUT_LOG = file("$buildDir/sidecar.out.log")
def ERR_LOG = file("$buildDir/sidecar.err.log")
def PID_FILE = file("$buildDir/sidecar.pid")
def STARTED_FLAG = file("$buildDir/sidecar.started")

/** 简单 HTTP 健康检查：返回 200 视为就绪 **/
def waitForHealthy = { String url, int timeoutSec ->
    long deadline = System.currentTimeMillis() + timeoutSec * 1000L
    while (System.currentTimeMillis() < deadline) {
        try {
            HttpURLConnection c = (HttpURLConnection) new URL(url).openConnection()
            c.setConnectTimeout(800); c.setReadTimeout(800); c.setRequestMethod("GET")
            if (c.getResponseCode() == 200) return true
        } catch (Throwable ignore) {}
        Thread.sleep(200)
    }
    return false
}

def runAndCapture(List<String> cmd) {
    Process p = new ProcessBuilder(cmd)
            .redirectErrorStream(true) // 合并 stderr，避免阻塞
            .start()
    ByteArrayOutputStream bout = new ByteArrayOutputStream()
    def inStream = p.getInputStream()
    byte[] buf = new byte[8192]
    int n
    try {
        while ((n = inStream.read(buf)) != -1) {
            bout.write(buf, 0, n)
        }
    } finally {
        try { inStream.close() } catch (Throwable ignored) {}
    }
    p.waitFor()
    return new String(bout.toByteArray(), Charset.defaultCharset()).trim()
}

def killByPidWindows = { String pid ->
    if (!pid) return
    runAndCapture(["cmd", "/c", "taskkill /PID " + pid + " /T /F"])
}

def pidsListeningOnPortWindows = { String port ->
    def out = runAndCapture([
            "cmd", "/c",
            "for /f \"tokens=5\" %a in ('netstat -ano ^| findstr :" + port + " ^| findstr LISTENING') do @echo %a"
    ])
    return out.readLines().collect { it.trim() }.findAll { it }
}

def pidsListeningOnPortUnix = { String port ->
    def out = runAndCapture([
            'bash', '-lc',
            'command -v lsof >/dev/null 2>&1 && lsof -ti tcp:' + port + ' || (command -v fuser >/dev/null 2>&1 && fuser ' + port + '/tcp 2>/dev/null | awk "{print \\$1}") || true'
    ])
    return out.readLines().collect { it.trim() }.findAll { it }
}

def killByPidUnix = { String pid ->
    if (!pid) return
    runAndCapture(["bash", "-lc", "kill -TERM " + pid + " || true; sleep 0.3; kill -KILL " + pid + " || true"])
}

def pidListeningOnPortUnix = { String port ->
    // lsof 不在时用 fallback
    def out = runAndCapture([
            'bash', '-lc',
            'command -v lsof >/dev/null 2>&1 && lsof -ti tcp:' + port + ' | head -n1 || (command -v fuser >/dev/null 2>&1 && fuser ' + port + '/tcp 2>/dev/null | awk "{print \$1}" | head -n1) || true'
    ])
    return out
}

task sidecarStart {
    group = "application"
    description = "Start sidecar.cjs in background and wait until /health is 200"
    doLast {

        // sidecar 已拉起，跳过拉起
        if (waitForHealthy(HEALTH_URL, 2)) {
            PID_FILE.delete()
            STARTED_FLAG.delete()
            println "[gradle] sidecar already running at ${HEALTH_URL}, skip starting."
            return
        }

        if (!file(SIDECAR_SCRIPT).exists()) {
            throw new GradleException("sidecar 脚本不存在: ${SIDECAR_SCRIPT}")
        }
        OUT_LOG.parentFile.mkdirs()
        ERR_LOG.parentFile.mkdirs()

        def pb = new ProcessBuilder(NODE_CMD, SIDECAR_SCRIPT)
        pb.directory(SIDECAR_DIR)

        def env = pb.environment()
        env.put("SIDECAR_PORT", SIDECAR_PORT)

        pb.redirectOutput(ProcessBuilder.Redirect.appendTo(OUT_LOG))
        pb.redirectError(ProcessBuilder.Redirect.appendTo(ERR_LOG))
        def p = pb.start()

        // 记录 PID（JDK9+ 可用；JDK8 取不到则写空）
        try {
            def pid = p.class.getMethod("pid").invoke(p)
            PID_FILE.text = pid.toString()
        } catch (Throwable t) {
            PID_FILE.text = ""
        }

        if (!waitForHealthy(HEALTH_URL, 30)) {
            throw new GradleException("sidecar 未在 30s 内通过健康检查: ${HEALTH_URL}\n请查看 ${ERR_LOG}")
        }
        println "[gradle] sidecar started on :${SIDECAR_PORT} (pid: ${PID_FILE.text?.trim()})"
        STARTED_FLAG.text = "started"
    }
}

task sidecarStop {
    group = "application"
    description = "Stop sidecar process by PID or fallback"

    doLast {
        boolean isWin = org.gradle.internal.os.OperatingSystem.current().isWindows()

        // 1) 先按 PID 文件杀一次（如果有）
        String pidFromFile = (PID_FILE.exists() ? PID_FILE.text.trim() : "")
        if (pidFromFile) {
            try {
                if (isWin) killByPidWindows(pidFromFile) else killByPidUnix(pidFromFile)
            } catch (Throwable ignore) {}
        }

        // 2) 兜底循环：每 300ms 扫描 LISTENING PID 并全部强杀，直到端口空或超时
        boolean freed = false
        int attempts = 0
        while (attempts++ < 20) { // 最多约 6 秒
            def pids = isWin ? pidsListeningOnPortWindows(SIDECAR_PORT) : pidsListeningOnPortUnix(SIDECAR_PORT)
            if (pids.isEmpty()) { freed = true; break }
            pids.unique().each { pid ->
                try {
                    if (isWin) killByPidWindows(pid) else killByPidUnix(pid)
                } catch (Throwable ignore) {}
            }
            Thread.sleep(300)
        }

        try { PID_FILE.delete() } catch (ignored) {}
        try { STARTED_FLAG.delete() } catch (ignored) {}

        println freed ?
                "[gradle] sidecar stopped and port ${SIDECAR_PORT} is free." :
                "[gradle] attempted stop, but port ${SIDECAR_PORT} still busy."
    }
}

// 与 Spring Boot 的 bootRun 关联（存在才挂钩，避免多模块误伤）
tasks.matching { it.name == 'bootRun' }.all { t ->
    t.dependsOn(sidecarStart)
    t.finalizedBy(sidecarStop)

    t.ignoreExitValue = true

    t.standardInput = System.in

    t.environment "SIDECAR_BASE", "http://127.0.0.1:${SIDECAR_PORT}"
}