import sjcl from './sjcl/index.js';
export declare function assertNever(name: string, x: unknown): never;
interface HashParams {
    name: string;
    hLen: number;
}
export declare function os2ip(bytes: Uint8Array): sjcl.BigNumber;
export declare function i2osp(num: sjcl.BigNumber, byteLength: number): Uint8Array;
export declare function int_to_bytes(num: number, byteLength: number): Uint8Array;
export declare function joinAll(a: Uint8Array[]): Uint8Array;
export declare function xor(a: Uint8Array, b: Uint8Array): Uint8Array;
type MGFFn = (h: HashParams, seed: Uint8Array, mLen: number) => Promise<Uint8Array>;
export declare function emsa_pss_encode(msg: Uint8Array, emBits: number, opts: {
    hash: string;
    sLen: number;
}, mgf?: MGFFn): Promise<Uint8Array>;
export declare function rsavp1(pkS: {
    n: sjcl.BigNumber;
    e: sjcl.BigNumber;
}, s: sjcl.BigNumber): sjcl.BigNumber;
export declare function rsasp1(skS: {
    n: sjcl.BigNumber;
    d: sjcl.BigNumber;
}, m: sjcl.BigNumber): sjcl.BigNumber;
export declare function is_coprime(x: sjcl.BigNumber, n: sjcl.BigNumber): boolean;
export declare function random_integer_uniform(n: sjcl.BigNumber, kLen: number): sjcl.BigNumber;
export declare function inverseMod(x: sjcl.BigNumber, p: sjcl.BigNumber): sjcl.BigNumber;
export declare const NATIVE_SUPPORT_NAME = "RSA-RAW";
export declare function rsaRawBlingSign(privateKey: CryptoKey, blindMsg: Uint8Array): Promise<Uint8Array>;
export type BigPublicKey = {
    e: sjcl.BigNumber;
    n: sjcl.BigNumber;
};
export type BigSecretKey = {
    d: sjcl.BigNumber;
    n: sjcl.BigNumber;
    p: sjcl.BigNumber;
    q: sjcl.BigNumber;
};
export type BigKeyPair = {
    publicKey: BigPublicKey;
    secretKey: BigSecretKey;
};
export declare function prepare_sjcl_random_generator(): void;
export {};
//# sourceMappingURL=util.d.ts.map