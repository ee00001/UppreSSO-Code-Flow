// Copyright (c) 2021 Cloudflare, Inc. and contributors.
// Copyright (c) 2021 Cloudflare, Inc.
// Licensed under the BSD-3-Clause license found in the LICENSE file or
// at https://opensource.org/licenses/BSD-3-Clause
import { DLEQProver } from './dleq.js';
import { Evaluation, Oprf } from './oprf.js';
import { ctEqual, zip } from './util.js';
class baseServer extends Oprf {
    constructor(mode, suite, privateKey, ...arg) {
        super(mode, suite, ...arg);
        this.prover = new DLEQProver(this.getDLEQParams(), this.crypto); // hook-able
        this.supportsWebCryptoOPRF = false;
        this.privateKey = privateKey;
    }
    doBlindEvaluation(blinded, key) {
        return this.supportsWebCryptoOPRF
            ? this.blindEvaluateWebCrypto(blinded, key)
            : Promise.resolve(this.blindEvaluateGroup(blinded, key));
    }
    async blindEvaluateWebCrypto(blinded, key) {
        const crKey = await crypto.subtle.importKey('raw', key, {
            name: 'OPRF',
            namedCurve: this.group.id
        }, true, ['sign']);
        // webcrypto accepts only compressed points.
        const compressed = blinded.serialize(true);
        const evalBytes = new Uint8Array(await crypto.subtle.sign('OPRF', crKey, compressed));
        return this.group.desElt(evalBytes);
    }
    blindEvaluateGroup(blinded, key) {
        return blinded.mul(this.group.desScalar(key));
    }
    async secretFromInfo(info) {
        const m = await this.scalarFromInfo(info);
        const skS = this.group.desScalar(this.privateKey);
        const t = m.add(skS);
        if (t.isZero()) {
            throw new Error('inverse of zero');
        }
        const tInv = t.inv();
        return [t, tInv];
    }
    async doEvaluate(input, info = new Uint8Array(0)) {
        let secret = this.privateKey;
        if (this.mode === Oprf.Mode.POPRF) {
            const [, evalSecret] = await this.secretFromInfo(info);
            secret = evalSecret.serialize();
        }
        const P = await this.group.hashToGroup(input, this.getDST(Oprf.LABELS.HashToGroupDST));
        if (P.isIdentity()) {
            throw new Error('InvalidInputError');
        }
        const evaluated = await this.doBlindEvaluation(P, secret);
        return this.coreFinalize(input, evaluated.serialize(true), info);
    }
}
export class OPRFServer extends baseServer {
    constructor(suite, privateKey, ...arg) {
        super(Oprf.Mode.OPRF, suite, privateKey, ...arg);
    }
    async blindEvaluate(req) {
        return new Evaluation(this.mode, await Promise.all(req.blinded.map((b) => this.doBlindEvaluation(b, this.privateKey))));
    }
    async evaluate(input) {
        return this.doEvaluate(input);
    }
    async verifyFinalize(input, output) {
        return ctEqual(output, await this.doEvaluate(input));
    }
}
export class VOPRFServer extends baseServer {
    constructor(suite, privateKey, ...arg) {
        super(Oprf.Mode.VOPRF, suite, privateKey, ...arg);
    }
    async blindEvaluate(req) {
        const evalList = await Promise.all(req.blinded.map((b) => this.doBlindEvaluation(b, this.privateKey)));
        const skS = this.group.desScalar(this.privateKey);
        const pkS = this.group.mulGen(skS);
        const proof = await this.prover.prove_batch(skS, [this.group.generator(), pkS], zip(req.blinded, evalList));
        return new Evaluation(this.mode, evalList, proof);
    }
    async evaluate(input) {
        return this.doEvaluate(input);
    }
    async verifyFinalize(input, output) {
        return ctEqual(output, await this.doEvaluate(input));
    }
}
export class POPRFServer extends baseServer {
    constructor(suite, privateKey, ...arg) {
        super(Oprf.Mode.POPRF, suite, privateKey, ...arg);
    }
    async blindEvaluate(req, info = new Uint8Array(0)) {
        const [keyProof, evalSecret] = await this.secretFromInfo(info);
        const secret = evalSecret.serialize();
        const evalList = await Promise.all(req.blinded.map((b) => this.doBlindEvaluation(b, secret)));
        const kG = this.group.mulGen(keyProof);
        const proof = await this.prover.prove_batch(keyProof, [this.group.generator(), kG], zip(evalList, req.blinded));
        return new Evaluation(this.mode, evalList, proof);
    }
    async evaluate(input, info = new Uint8Array(0)) {
        return this.doEvaluate(input, info);
    }
    async verifyFinalize(input, output, info = new Uint8Array(0)) {
        return ctEqual(output, await this.doEvaluate(input, info));
    }
}
//# sourceMappingURL=server.js.map