import type { CryptoProvider, HashID } from './cryptoTypes.js';
import type { Elt, Group, GroupID, Scalar } from './groupTypes.js';
import { type CryptoProviderArg } from './cryptoImpl.js';
export interface DLEQParams {
    readonly dst: Uint8Array;
    readonly group: GroupID;
    readonly hash: HashID;
}
export declare class DLEQProof {
    readonly c: Scalar;
    readonly s: Scalar;
    constructor(c: Scalar, s: Scalar);
    isEqual(p: DLEQProof): boolean;
    serialize(): Uint8Array;
    static size(group: Group): number;
    static deserialize(groupID: GroupID, bytes: Uint8Array, ...arg: CryptoProviderArg): DLEQProof;
}
export declare class DLEQVerifier {
    readonly params: DLEQParams;
    readonly crypto: CryptoProvider;
    readonly group: Group;
    constructor(params: DLEQParams, ...arg: CryptoProviderArg);
    verify(p0: [Elt, Elt], p1: [Elt, Elt], proof: DLEQProof): Promise<boolean>;
    verify_batch(p0: [Elt, Elt], p1s: Array<[Elt, Elt]>, proof: DLEQProof): Promise<boolean>;
}
export declare class DLEQProver extends DLEQVerifier {
    prove(k: Scalar, p0: [Elt, Elt], p1: [Elt, Elt], r?: Scalar): Promise<DLEQProof>;
    randomScalar(): Promise<Scalar>;
    prove_batch(key: Scalar, p0: [Elt, Elt], p1s: Array<[Elt, Elt]>, r?: Scalar): Promise<DLEQProof>;
}
//# sourceMappingURL=dleq.d.ts.map