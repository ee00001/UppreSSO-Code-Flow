// Copyright (c) 2021 Cloudflare, Inc. and contributors.
// Copyright (c) 2021 Cloudflare, Inc.
// Licensed under the BSD-3-Clause license found in the LICENSE file or
// at https://opensource.org/licenses/BSD-3-Clause
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _GroupNb_cache;
import { bytesToNumberBE, bytesToNumberLE } from '@noble/curves/abstract/utils';
import { GROUP } from '../groupTypes.js';
import { ScalarNb } from './scalar.js';
import { EltNb } from './element.js';
import { getParams } from './params.js';
export class GroupNb {
    static get(gid) {
        let { [gid]: group } = __classPrivateFieldGet(this, _a, "f", _GroupNb_cache);
        if (!group) {
            group = new this(gid);
            Object.assign(__classPrivateFieldGet(this, _a, "f", _GroupNb_cache), { gid: group });
        }
        return group;
    }
    constructor(gid) {
        this.eltDes = {
            size: (compressed) => this.eltSize(compressed),
            deserialize: (b) => this.desElt(b)
        };
        this.scalarDes = {
            size: () => this.scalarSize(),
            deserialize: (b) => this.desScalar(b)
        };
        this.params = getParams(gid);
        this.id = gid;
    }
    bytesToNumber(bytes) {
        return this.params.isEdwards ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    }
    newScalar() {
        return ScalarNb.create(this);
    }
    newElt() {
        return this.identity();
    }
    identity() {
        return EltNb.create(this);
    }
    generator() {
        return EltNb.gen(this);
    }
    mulGen(s) {
        return EltNb.gen(this).mul(s);
    }
    randomScalar() {
        const msg = crypto.getRandomValues(new Uint8Array(this.params.scalar.size));
        return Promise.resolve(ScalarNb.hash(this, msg, new Uint8Array()));
    }
    hashToGroup(msg, dst) {
        return Promise.resolve(EltNb.hash(this, msg, dst));
    }
    hashToScalar(msg, dst) {
        return Promise.resolve(ScalarNb.hash(this, msg, dst));
    }
    desElt(bytes) {
        return EltNb.deserialize(this, bytes);
    }
    desScalar(bytes) {
        return ScalarNb.deserialize(this, bytes);
    }
    eltSize(compressed) {
        return EltNb.size(this, compressed);
    }
    scalarSize() {
        return ScalarNb.size(this);
    }
}
_a = GroupNb;
GroupNb.supportedGroups = [
    GROUP.RISTRETTO255,
    GROUP.DECAF448,
    GROUP.P256,
    GROUP.P384,
    GROUP.P521
];
_GroupNb_cache = { value: {} };
//# sourceMappingURL=group.js.map