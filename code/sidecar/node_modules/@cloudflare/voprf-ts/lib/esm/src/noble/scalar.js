// Copyright (c) 2021 Cloudflare, Inc. and contributors.
// Copyright (c) 2021 Cloudflare, Inc.
// Licensed under the BSD-3-Clause license found in the LICENSE file or
// at https://opensource.org/licenses/BSD-3-Clause
import { expand_message_xmd, expand_message_xof, hash_to_field } from '@noble/curves/abstract/hash-to-curve';
import { checkSize, compat, errDeserialization } from '../util.js';
export class ScalarNb {
    constructor(g, k) {
        this.g = g;
        this.field = this.g.params.scalar.field;
        this.k = this.field.create(k);
    }
    static create(g) {
        return new ScalarNb(g, BigInt(0));
    }
    isEqual(s) {
        compat(this, s);
        return this.k === s.k;
    }
    isZero() {
        return this.k === BigInt(0);
    }
    add(s) {
        compat(this, s);
        return new ScalarNb(this.g, this.field.add(this.k, s.k));
    }
    sub(s) {
        compat(this, s);
        return new ScalarNb(this.g, this.field.sub(this.k, s.k));
    }
    mul(s) {
        compat(this, s);
        return new ScalarNb(this.g, this.field.mul(this.k, s.k));
    }
    inv() {
        return new ScalarNb(this.g, this.field.inv(this.k));
    }
    serialize() {
        return this.field.toBytes(this.k);
    }
    static size(g) {
        return g.params.scalar.size;
    }
    static deserialize(g, bytes) {
        checkSize(bytes, ScalarNb, g);
        const array = bytes.subarray(0, g.params.scalar.size);
        const k = g.bytesToNumber(array);
        if (k >= g.params.scalar.field.ORDER) {
            throw errDeserialization(ScalarNb);
        }
        return new ScalarNb(g, k);
    }
    static hash(g, msg, dst) {
        const { scalar, hash } = g.params;
        if (scalar.hash.type === 'hash_to_field') {
            const [[k]] = hash_to_field(msg, 1, {
                ...{ hash: hash.fn },
                ...scalar.hash.params,
                DST: dst,
                m: 1
            });
            return new ScalarNb(g, k);
        }
        else {
            const uniform = scalar.hash.type === 'xmd'
                ? expand_message_xmd(msg, dst, hash.size, hash.fn)
                : expand_message_xof(msg, dst, hash.size, scalar.hash.k, hash.fn);
            const k1 = scalar.field.create(g.bytesToNumber(uniform));
            return new ScalarNb(g, k1);
        }
    }
}
//# sourceMappingURL=scalar.js.map