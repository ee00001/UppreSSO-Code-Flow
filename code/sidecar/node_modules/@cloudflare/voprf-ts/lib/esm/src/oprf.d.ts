import { type DLEQParams, DLEQProof } from './dleq.js';
import { type Elt, type Group, type GroupCons, type GroupID, type Scalar } from './groupTypes.js';
import type { CryptoProvider, HashID } from './cryptoTypes.js';
import { type CryptoProviderArg } from './cryptoImpl.js';
export type ModeID = (typeof Oprf.Mode)[keyof typeof Oprf.Mode];
export type SuiteID = (typeof Oprf.Suite)[keyof typeof Oprf.Suite];
export declare function getOprfParams(id: string): readonly [suite: SuiteID, group: GroupID, hash: HashID, size: number];
export declare function getSupportedSuites(g: GroupCons): Array<SuiteID>;
export declare abstract class Oprf {
    static set Crypto(provider: CryptoProvider);
    static get Crypto(): CryptoProvider;
    static Mode: {
        readonly OPRF: 0;
        readonly VOPRF: 1;
        readonly POPRF: 2;
    };
    static Suite: {
        readonly P256_SHA256: "P256-SHA256";
        readonly P384_SHA384: "P384-SHA384";
        readonly P521_SHA512: "P521-SHA512";
        readonly RISTRETTO255_SHA512: "ristretto255-SHA512";
        readonly DECAF448_SHAKE256: "decaf448-SHAKE256";
    };
    static LABELS: {
        readonly Version: "OPRFV1-";
        readonly FinalizeDST: "Finalize";
        readonly HashToGroupDST: "HashToGroup-";
        readonly HashToScalarDST: "HashToScalar-";
        readonly DeriveKeyPairDST: "DeriveKeyPair";
        readonly InfoLabel: "Info";
    };
    private static validateMode;
    static getGroup(suite: SuiteID, ...arg: CryptoProviderArg): Group;
    static getHash(suite: SuiteID): HashID;
    static getOprfSize(suite: SuiteID): number;
    static getDST(mode: ModeID, suite: SuiteID, name: string): Uint8Array;
    readonly mode: ModeID;
    readonly suite: SuiteID;
    readonly hashID: HashID;
    readonly group: Group;
    readonly crypto: CryptoProvider;
    protected constructor(mode: ModeID, suite: SuiteID, ...arg: CryptoProviderArg);
    protected getDLEQParams(): DLEQParams;
    protected getDST(name: string): Uint8Array;
    protected coreFinalize(input: Uint8Array, issuedElement: Uint8Array, info: Uint8Array): Promise<Uint8Array>;
    protected scalarFromInfo(info: Uint8Array): Promise<Scalar>;
}
export declare class Evaluation {
    readonly mode: ModeID;
    readonly evaluated: Array<Elt>;
    readonly proof?: DLEQProof | undefined;
    constructor(mode: ModeID, evaluated: Array<Elt>, proof?: DLEQProof | undefined);
    serialize(): Uint8Array;
    isEqual(e: Evaluation): boolean;
    static deserialize(suite: SuiteID, bytes: Uint8Array, ...arg: CryptoProviderArg): Evaluation;
}
export declare class EvaluationRequest {
    readonly blinded: Array<Elt>;
    constructor(blinded: Array<Elt>);
    serialize(): Uint8Array;
    isEqual(e: EvaluationRequest): boolean;
    static deserialize(suite: SuiteID, bytes: Uint8Array, ...arg: CryptoProviderArg): EvaluationRequest;
}
export declare class FinalizeData {
    readonly inputs: Array<Uint8Array>;
    readonly blinds: Array<Scalar>;
    readonly evalReq: EvaluationRequest;
    constructor(inputs: Array<Uint8Array>, blinds: Array<Scalar>, evalReq: EvaluationRequest);
    serialize(): Uint8Array;
    isEqual(f: FinalizeData): boolean;
    static deserialize(suite: SuiteID, bytes: Uint8Array, ...arg: CryptoProviderArg): FinalizeData;
}
//# sourceMappingURL=oprf.d.ts.map