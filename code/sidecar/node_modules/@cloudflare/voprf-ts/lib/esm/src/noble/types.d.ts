import type { Field } from '@noble/curves/abstract/modular';
import type { CHash } from '@noble/hashes/utils';
import type * as p256 from '@noble/curves/p256';
import type * as ed25519 from '@noble/curves/ed25519';
import type * as ed448 from '@noble/curves/ed448';
import type { Hex } from '@noble/curves/abstract/utils';
import type { HashID } from '../cryptoTypes.js';
export type PrimeField = ReturnType<typeof Field>;
export type HashToPointFunc = typeof p256.hashToCurve | typeof ed25519.hashToRistretto255 | typeof ed448.hashToDecaf448;
export type ScalarHash = {
    type: 'hash_to_field';
    params: {
        k: number;
        p: bigint;
        expand: 'xmd';
    };
} | {
    type: 'xmd';
} | {
    type: 'xof';
    k: number;
};
export interface ElementSize {
    compressed: number;
    standard: number;
}
export interface Element {
    Point: PointConstructor;
    hash: HashToPointFunc;
    size: ElementSize;
}
export type ElementSpec = Pick<Element, 'Point' | 'hash'>;
export interface GroupParams {
    isEdwards: boolean;
    scalar: {
        field: PrimeField;
        size: number;
        hash: ScalarHash;
    };
    element: Element;
    hash: {
        id: HashID;
        size: number;
        fn: CHash;
    };
}
export interface PointOptionals {
    negate?(): Point;
    multiplyAndAddUnsafe?(p: Point, k: bigint, k2: bigint): Point | null;
    assertValidity?: () => void;
}
export interface Point extends PointOptionals {
    add(p: Point): Point;
    equals(p: Point): boolean;
    multiply(k: bigint): Point;
    toRawBytes(compressed: boolean): Uint8Array;
}
export interface PointConstructor {
    ZERO: Point;
    BASE: Point;
    fromHex(hex: Hex): Point;
}
//# sourceMappingURL=types.d.ts.map