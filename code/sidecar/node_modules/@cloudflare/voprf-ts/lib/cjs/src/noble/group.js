"use strict";
// Copyright (c) 2021 Cloudflare, Inc. and contributors.
// Copyright (c) 2021 Cloudflare, Inc.
// Licensed under the BSD-3-Clause license found in the LICENSE file or
// at https://opensource.org/licenses/BSD-3-Clause
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _GroupNb_cache;
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupNb = void 0;
const utils_1 = require("@noble/curves/abstract/utils");
const groupTypes_js_1 = require("../groupTypes.js");
const scalar_js_1 = require("./scalar.js");
const element_js_1 = require("./element.js");
const params_js_1 = require("./params.js");
class GroupNb {
    static get(gid) {
        let { [gid]: group } = __classPrivateFieldGet(this, _a, "f", _GroupNb_cache);
        if (!group) {
            group = new this(gid);
            Object.assign(__classPrivateFieldGet(this, _a, "f", _GroupNb_cache), { gid: group });
        }
        return group;
    }
    constructor(gid) {
        this.eltDes = {
            size: (compressed) => this.eltSize(compressed),
            deserialize: (b) => this.desElt(b)
        };
        this.scalarDes = {
            size: () => this.scalarSize(),
            deserialize: (b) => this.desScalar(b)
        };
        this.params = (0, params_js_1.getParams)(gid);
        this.id = gid;
    }
    bytesToNumber(bytes) {
        return this.params.isEdwards ? (0, utils_1.bytesToNumberLE)(bytes) : (0, utils_1.bytesToNumberBE)(bytes);
    }
    newScalar() {
        return scalar_js_1.ScalarNb.create(this);
    }
    newElt() {
        return this.identity();
    }
    identity() {
        return element_js_1.EltNb.create(this);
    }
    generator() {
        return element_js_1.EltNb.gen(this);
    }
    mulGen(s) {
        return element_js_1.EltNb.gen(this).mul(s);
    }
    randomScalar() {
        const msg = crypto.getRandomValues(new Uint8Array(this.params.scalar.size));
        return Promise.resolve(scalar_js_1.ScalarNb.hash(this, msg, new Uint8Array()));
    }
    hashToGroup(msg, dst) {
        return Promise.resolve(element_js_1.EltNb.hash(this, msg, dst));
    }
    hashToScalar(msg, dst) {
        return Promise.resolve(scalar_js_1.ScalarNb.hash(this, msg, dst));
    }
    desElt(bytes) {
        return element_js_1.EltNb.deserialize(this, bytes);
    }
    desScalar(bytes) {
        return scalar_js_1.ScalarNb.deserialize(this, bytes);
    }
    eltSize(compressed) {
        return element_js_1.EltNb.size(this, compressed);
    }
    scalarSize() {
        return scalar_js_1.ScalarNb.size(this);
    }
}
exports.GroupNb = GroupNb;
_a = GroupNb;
GroupNb.supportedGroups = [
    groupTypes_js_1.GROUP.RISTRETTO255,
    groupTypes_js_1.GROUP.DECAF448,
    groupTypes_js_1.GROUP.P256,
    groupTypes_js_1.GROUP.P384,
    groupTypes_js_1.GROUP.P521
];
_GroupNb_cache = { value: {} };
//# sourceMappingURL=group.js.map