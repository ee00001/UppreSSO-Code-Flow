"use strict";
// Copyright (c) 2021 Cloudflare, Inc. and contributors.
// Copyright (c) 2021 Cloudflare, Inc.
// Licensed under the BSD-3-Clause license found in the LICENSE file or
// at https://opensource.org/licenses/BSD-3-Clause
Object.defineProperty(exports, "__esModule", { value: true });
exports.POPRFServer = exports.VOPRFServer = exports.OPRFServer = void 0;
const dleq_js_1 = require("./dleq.js");
const oprf_js_1 = require("./oprf.js");
const util_js_1 = require("./util.js");
class baseServer extends oprf_js_1.Oprf {
    constructor(mode, suite, privateKey, ...arg) {
        super(mode, suite, ...arg);
        this.prover = new dleq_js_1.DLEQProver(this.getDLEQParams(), this.crypto); // hook-able
        this.supportsWebCryptoOPRF = false;
        this.privateKey = privateKey;
    }
    doBlindEvaluation(blinded, key) {
        return this.supportsWebCryptoOPRF
            ? this.blindEvaluateWebCrypto(blinded, key)
            : Promise.resolve(this.blindEvaluateGroup(blinded, key));
    }
    async blindEvaluateWebCrypto(blinded, key) {
        const crKey = await crypto.subtle.importKey('raw', key, {
            name: 'OPRF',
            namedCurve: this.group.id
        }, true, ['sign']);
        // webcrypto accepts only compressed points.
        const compressed = blinded.serialize(true);
        const evalBytes = new Uint8Array(await crypto.subtle.sign('OPRF', crKey, compressed));
        return this.group.desElt(evalBytes);
    }
    blindEvaluateGroup(blinded, key) {
        return blinded.mul(this.group.desScalar(key));
    }
    async secretFromInfo(info) {
        const m = await this.scalarFromInfo(info);
        const skS = this.group.desScalar(this.privateKey);
        const t = m.add(skS);
        if (t.isZero()) {
            throw new Error('inverse of zero');
        }
        const tInv = t.inv();
        return [t, tInv];
    }
    async doEvaluate(input, info = new Uint8Array(0)) {
        let secret = this.privateKey;
        if (this.mode === oprf_js_1.Oprf.Mode.POPRF) {
            const [, evalSecret] = await this.secretFromInfo(info);
            secret = evalSecret.serialize();
        }
        const P = await this.group.hashToGroup(input, this.getDST(oprf_js_1.Oprf.LABELS.HashToGroupDST));
        if (P.isIdentity()) {
            throw new Error('InvalidInputError');
        }
        const evaluated = await this.doBlindEvaluation(P, secret);
        return this.coreFinalize(input, evaluated.serialize(true), info);
    }
}
class OPRFServer extends baseServer {
    constructor(suite, privateKey, ...arg) {
        super(oprf_js_1.Oprf.Mode.OPRF, suite, privateKey, ...arg);
    }
    async blindEvaluate(req) {
        return new oprf_js_1.Evaluation(this.mode, await Promise.all(req.blinded.map((b) => this.doBlindEvaluation(b, this.privateKey))));
    }
    async evaluate(input) {
        return this.doEvaluate(input);
    }
    async verifyFinalize(input, output) {
        return (0, util_js_1.ctEqual)(output, await this.doEvaluate(input));
    }
}
exports.OPRFServer = OPRFServer;
class VOPRFServer extends baseServer {
    constructor(suite, privateKey, ...arg) {
        super(oprf_js_1.Oprf.Mode.VOPRF, suite, privateKey, ...arg);
    }
    async blindEvaluate(req) {
        const evalList = await Promise.all(req.blinded.map((b) => this.doBlindEvaluation(b, this.privateKey)));
        const skS = this.group.desScalar(this.privateKey);
        const pkS = this.group.mulGen(skS);
        const proof = await this.prover.prove_batch(skS, [this.group.generator(), pkS], (0, util_js_1.zip)(req.blinded, evalList));
        return new oprf_js_1.Evaluation(this.mode, evalList, proof);
    }
    async evaluate(input) {
        return this.doEvaluate(input);
    }
    async verifyFinalize(input, output) {
        return (0, util_js_1.ctEqual)(output, await this.doEvaluate(input));
    }
}
exports.VOPRFServer = VOPRFServer;
class POPRFServer extends baseServer {
    constructor(suite, privateKey, ...arg) {
        super(oprf_js_1.Oprf.Mode.POPRF, suite, privateKey, ...arg);
    }
    async blindEvaluate(req, info = new Uint8Array(0)) {
        const [keyProof, evalSecret] = await this.secretFromInfo(info);
        const secret = evalSecret.serialize();
        const evalList = await Promise.all(req.blinded.map((b) => this.doBlindEvaluation(b, secret)));
        const kG = this.group.mulGen(keyProof);
        const proof = await this.prover.prove_batch(keyProof, [this.group.generator(), kG], (0, util_js_1.zip)(evalList, req.blinded));
        return new oprf_js_1.Evaluation(this.mode, evalList, proof);
    }
    async evaluate(input, info = new Uint8Array(0)) {
        return this.doEvaluate(input, info);
    }
    async verifyFinalize(input, output, info = new Uint8Array(0)) {
        return (0, util_js_1.ctEqual)(output, await this.doEvaluate(input, info));
    }
}
exports.POPRFServer = POPRFServer;
//# sourceMappingURL=server.js.map