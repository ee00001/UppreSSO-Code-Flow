"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerImpl = void 0;
const server_js_1 = require("../../server.js");
const consts_js_1 = require("../../consts.js");
const OprfBaseImpl_js_1 = require("./OprfBaseImpl.js");
class ServerImpl extends OprfBaseImpl_js_1.OprfBaseImpl {
    constructor(privateKey, ...args) {
        super(...args);
        let wrapped;
        switch (this.mode) {
            case consts_js_1.MODE.OPRF:
                wrapped = new server_js_1.OPRFServer(this.suite, privateKey, this.crypto);
                break;
            case consts_js_1.MODE.POPRF:
                wrapped = new server_js_1.POPRFServer(this.suite, privateKey, this.crypto);
                break;
            case consts_js_1.MODE.VOPRF:
                wrapped = new server_js_1.VOPRFServer(this.suite, privateKey, this.crypto);
                break;
            default:
                throw new Error(`Unsupported mode: ${this.mode}`);
        }
        this.spyHandle = {
            dleqProver: wrapped['prover']
        };
        this.verifyFinalize = wrapped.verifyFinalize.bind(wrapped);
        this.blindEvaluate = async (req, ...info) => {
            const internal = await wrapped.blindEvaluate(this.codec.decodeEvaluationRequest(req), ...info);
            return this.codec.encodeEvaluation(internal);
        };
    }
}
exports.ServerImpl = ServerImpl;
//# sourceMappingURL=ServerImpl.js.map