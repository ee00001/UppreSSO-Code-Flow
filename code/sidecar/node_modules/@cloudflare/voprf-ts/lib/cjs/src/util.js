"use strict";
// Copyright (c) 2021 Cloudflare, Inc. and contributors.
// Copyright (c) 2021 Cloudflare, Inc.
// Licensed under the BSD-3-Clause license found in the LICENSE file or
// at https://opensource.org/licenses/BSD-3-Clause
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinAll = joinAll;
exports.xor = xor;
exports.ctEqual = ctEqual;
exports.zip = zip;
exports.to16bits = to16bits;
exports.toU16LenPrefix = toU16LenPrefix;
exports.toU16LenPrefixUint8Array = toU16LenPrefixUint8Array;
exports.toU16LenPrefixClass = toU16LenPrefixClass;
exports.fromU16LenPrefix = fromU16LenPrefix;
exports.fromU16LenPrefixDes = fromU16LenPrefixDes;
exports.fromU16LenPrefixUint8Array = fromU16LenPrefixUint8Array;
exports.checkSize = checkSize;
exports.errDeserialization = errDeserialization;
exports.errGroup = errGroup;
exports.compat = compat;
function joinAll(a) {
    let size = 0;
    for (const ai of a) {
        size += ai.length;
    }
    const ret = new Uint8Array(new ArrayBuffer(size));
    let offset = 0;
    for (const ai of a) {
        ret.set(ai, offset);
        offset += ai.length;
    }
    return ret;
}
function xor(a, b) {
    if (a.length !== b.length || a.length === 0) {
        throw new Error('arrays of different length');
    }
    const n = a.length;
    const c = new Uint8Array(n);
    for (let i = 0; i < n; i++) {
        c[i] = a[i] ^ b[i];
    }
    return c;
}
function ctEqual(a, b) {
    if (a.length !== b.length || a.length === 0) {
        return false;
    }
    const n = a.length;
    let c = 0;
    for (let i = 0; i < n; i++) {
        c |= a[i] ^ b[i];
    }
    return c === 0;
}
function zip(x, y) {
    return x.map((xi, i) => [xi, y[i]]);
}
function to16bits(n) {
    if (!(n >= 0 && n < 0xffff)) {
        throw new Error('number bigger than 2^16');
    }
    return new Uint8Array([(n >> 8) & 0xff, n & 0xff]);
}
function toU16LenPrefix(b) {
    return [to16bits(b.length), b];
}
function toU16LenPrefixUint8Array(b) {
    return [to16bits(b.length), ...b.flatMap((x) => toU16LenPrefix(x))];
}
function toU16LenPrefixClass(b) {
    return [to16bits(b.length), ...b.map((x) => x.serialize())];
}
function fromU16LenPrefix(b) {
    if (b.length < 2) {
        throw new Error(`buffer shorter than expected`);
    }
    const n = (b[0] << 8) | b[1];
    if (b.length < 2 + n) {
        throw new Error(`buffer shorter than expected`);
    }
    const head = b.subarray(2, 2 + n);
    const tail = b.subarray(2 + n);
    return { head, tail };
}
function fromU16LenPrefixDes(c, b) {
    if (b.length < 2) {
        throw new Error(`buffer shorter than expected`);
    }
    const n = (b[0] << 8) | b[1];
    const size = c.size();
    if (b.length < 2 + n * size) {
        throw new Error(`buffer shorter than expected`);
    }
    const head = [];
    for (let i = 0; i < n; i++) {
        head.push(c.deserialize(b.subarray(2 + i * size, 2 + (i + 1) * size)));
    }
    const tail = b.subarray(2 + n * size);
    return { head, tail };
}
function fromU16LenPrefixUint8Array(b) {
    if (b.length < 2) {
        throw new Error(`buffer shorter than expected`);
    }
    const n = (b[0] << 8) | b[1];
    let run = b.subarray(2);
    const output = [];
    for (let i = 0; i < n; i++) {
        const { head, tail } = fromU16LenPrefix(run);
        output.push(head);
        run = tail;
    }
    return { head: output, tail: run };
}
function checkSize(x, T, u) {
    if (x.length < T.size(u)) {
        throw new Error(`error deserializing ${T.name}: buffer shorter than expected`);
    }
}
function errDeserialization(T) {
    return new Error(`group: deserialization of ${T.name} failed.`);
}
function errGroup(X, Y) {
    return new Error(`group: mismatch between groups ${X} and ${Y}.`);
}
function compat(x, y) {
    if (x.g.id !== y.g.id)
        throw errGroup(x.g.id, y.g.id);
}
//# sourceMappingURL=util.js.map