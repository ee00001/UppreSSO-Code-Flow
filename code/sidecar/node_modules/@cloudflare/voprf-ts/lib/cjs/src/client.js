"use strict";
// Copyright (c) 2021 Cloudflare, Inc. and contributors.
// Copyright (c) 2021 Cloudflare, Inc.
// Licensed under the BSD-3-Clause license found in the LICENSE file or
// at https://opensource.org/licenses/BSD-3-Clause
Object.defineProperty(exports, "__esModule", { value: true });
exports.POPRFClient = exports.VOPRFClient = exports.OPRFClient = void 0;
const oprf_js_1 = require("./oprf.js");
const util_js_1 = require("./util.js");
const dleq_js_1 = require("./dleq.js");
class baseClient extends oprf_js_1.Oprf {
    randomBlinder() {
        return this.group.randomScalar();
    }
    async blind(inputs) {
        const eltList = [];
        const blinds = [];
        for (const input of inputs) {
            const scalar = await this.randomBlinder();
            const inputElement = await this.group.hashToGroup(input, this.getDST(oprf_js_1.Oprf.LABELS.HashToGroupDST));
            if (inputElement.isIdentity()) {
                throw new Error('InvalidInputError');
            }
            eltList.push(inputElement.mul(scalar));
            blinds.push(scalar);
        }
        const evalReq = new oprf_js_1.EvaluationRequest(eltList);
        const finData = new oprf_js_1.FinalizeData(inputs, blinds, evalReq);
        return [finData, evalReq];
    }
    async doFinalize(finData, evaluation, info = new Uint8Array(0)) {
        const n = finData.inputs.length;
        if (finData.blinds.length !== n || evaluation.evaluated.length !== n) {
            throw new Error('mismatched lengths');
        }
        const outputList = [];
        for (let i = 0; i < n; i++) {
            const blindInv = finData.blinds[i].inv();
            const N = evaluation.evaluated[i].mul(blindInv);
            const unblinded = N.serialize();
            outputList.push(await this.coreFinalize(finData.inputs[i], unblinded, info));
        }
        return outputList;
    }
}
class OPRFClient extends baseClient {
    constructor(suite, ...arg) {
        super(oprf_js_1.Oprf.Mode.OPRF, suite, ...arg);
    }
    finalize(finData, evaluation) {
        return super.doFinalize(finData, evaluation);
    }
}
exports.OPRFClient = OPRFClient;
class VOPRFClient extends baseClient {
    constructor(suite, pubKeyServer, ...arg) {
        super(oprf_js_1.Oprf.Mode.VOPRF, suite, ...arg);
        this.pubKeyServer = pubKeyServer;
    }
    async finalize(finData, evaluation) {
        if (!evaluation.proof) {
            throw new Error('no proof provided');
        }
        const pkS = this.group.desElt(this.pubKeyServer);
        const n = finData.inputs.length;
        if (evaluation.evaluated.length !== n) {
            throw new Error('mismatched lengths');
        }
        const verifier = new dleq_js_1.DLEQVerifier(this.getDLEQParams(), this.crypto);
        if (!(await verifier.verify_batch([this.group.generator(), pkS], (0, util_js_1.zip)(finData.evalReq.blinded, evaluation.evaluated), evaluation.proof))) {
            throw new Error('proof failed');
        }
        return super.doFinalize(finData, evaluation);
    }
}
exports.VOPRFClient = VOPRFClient;
class POPRFClient extends baseClient {
    constructor(suite, pubKeyServer, ...arg) {
        super(oprf_js_1.Oprf.Mode.POPRF, suite, ...arg);
        this.pubKeyServer = pubKeyServer;
    }
    async pointFromInfo(info) {
        const m = await this.scalarFromInfo(info);
        const T = this.group.mulGen(m);
        const pkS = this.group.desElt(this.pubKeyServer);
        const tw = pkS.add(T);
        if (tw.isIdentity()) {
            throw new Error('invalid info');
        }
        return tw;
    }
    async finalize(finData, evaluation, info = new Uint8Array(0)) {
        if (!evaluation.proof) {
            throw new Error('no proof provided');
        }
        const tw = await this.pointFromInfo(info);
        const n = finData.inputs.length;
        if (evaluation.evaluated.length !== n) {
            throw new Error('mismatched lengths');
        }
        const verifier = new dleq_js_1.DLEQVerifier(this.getDLEQParams(), this.crypto);
        if (!(await verifier.verify_batch([this.group.generator(), tw], (0, util_js_1.zip)(evaluation.evaluated, finData.evalReq.blinded), evaluation.proof))) {
            throw new Error('proof failed');
        }
        return super.doFinalize(finData, evaluation, info);
    }
}
exports.POPRFClient = POPRFClient;
//# sourceMappingURL=client.js.map