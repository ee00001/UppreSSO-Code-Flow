"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DLEQProver = exports.DLEQVerifier = exports.DLEQProof = void 0;
const util_js_1 = require("./util.js");
const cryptoImpl_js_1 = require("./cryptoImpl.js");
const LABELS = {
    Seed: 'Seed-',
    Challenge: 'Challenge',
    Composite: 'Composite',
    HashToScalar: 'HashToScalar-'
};
// computeComposites implements ComputeComposites and ComputeCompositiesFast
// functions from https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf-21#name-discrete-logarithm-equivale
async function computeComposites(params, b, cd, key, ...arg) {
    const crypto = (0, cryptoImpl_js_1.getCrypto)(arg);
    const group = crypto.Group.get(params.group);
    const te = new TextEncoder();
    const Bm = b.serialize();
    const seedDST = (0, util_js_1.joinAll)([te.encode(LABELS.Seed), params.dst]);
    const h1Input = (0, util_js_1.joinAll)([...(0, util_js_1.toU16LenPrefix)(Bm), ...(0, util_js_1.toU16LenPrefix)(seedDST)]);
    const seed = await crypto.hash(params.hash, h1Input);
    const compositeLabel = te.encode(LABELS.Composite);
    const h2sDST = (0, util_js_1.joinAll)([te.encode(LABELS.HashToScalar), params.dst]);
    let M = group.identity();
    let Z = group.identity();
    let i = 0;
    for (const [c, d] of cd) {
        const Ci = c.serialize();
        const Di = d.serialize();
        const h2Input = (0, util_js_1.joinAll)([
            ...(0, util_js_1.toU16LenPrefix)(seed),
            (0, util_js_1.to16bits)(i++),
            ...(0, util_js_1.toU16LenPrefix)(Ci),
            ...(0, util_js_1.toU16LenPrefix)(Di),
            compositeLabel
        ]);
        const di = await group.hashToScalar(h2Input, h2sDST);
        M = M.add(c.mul(di));
        if (!key) {
            Z = Z.add(d.mul(di));
        }
    }
    if (key) {
        Z = M.mul(key);
    }
    return { M, Z };
}
// challenge implements the shared subprocedure for generating a challenge
// used by the GenerateProof and VerifyProof functions
// from https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf-21#name-discrete-logarithm-equivale
// to generate a challenge from the input elements. The point arguments
// correspond to [B, M, Z, t2, t3] from the specification.
function challenge(group, params, points) {
    let h2Input = new Uint8Array();
    for (const p of points) {
        const P = p.serialize();
        h2Input = (0, util_js_1.joinAll)([h2Input, ...(0, util_js_1.toU16LenPrefix)(P)]);
    }
    const te = new TextEncoder();
    h2Input = (0, util_js_1.joinAll)([h2Input, te.encode(LABELS.Challenge)]);
    const h2sDST = (0, util_js_1.joinAll)([te.encode(LABELS.HashToScalar), params.dst]);
    return group.hashToScalar(h2Input, h2sDST);
}
class DLEQProof {
    constructor(c, s) {
        this.c = c;
        this.s = s;
    }
    isEqual(p) {
        return this.c.isEqual(p.c) && this.s.isEqual(p.s);
    }
    serialize() {
        return (0, util_js_1.joinAll)([this.c.serialize(), this.s.serialize()]);
    }
    static size(group) {
        return 2 * group.scalarSize();
    }
    static deserialize(groupID, bytes, ...arg) {
        const group = (0, cryptoImpl_js_1.getGroup)(groupID, arg);
        (0, util_js_1.checkSize)(bytes, DLEQProof, group);
        const n = group.scalarSize();
        const c = group.desScalar(bytes.subarray(0, n));
        const s = group.desScalar(bytes.subarray(n, 2 * n));
        return new DLEQProof(c, s);
    }
}
exports.DLEQProof = DLEQProof;
class DLEQVerifier {
    constructor(params, ...arg) {
        this.params = params;
        this.crypto = (0, cryptoImpl_js_1.getCrypto)(arg);
        this.group = this.crypto.Group.get(params.group);
    }
    verify(p0, p1, proof) {
        return this.verify_batch(p0, [p1], proof);
    }
    // verify_batch implements the VerifyProof function
    // from https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf-21#name-discrete-logarithm-equivale
    // The argument p0 corresponds to the elements A, B, and the argument p1s
    // corresponds to the arrays of elements C and D from the specification.
    async verify_batch(p0, p1s, proof) {
        const { M, Z } = await computeComposites(this.params, p0[1], p1s, undefined, this.crypto);
        const t2 = p0[0].mul2(proof.s, p0[1], proof.c);
        const t3 = M.mul2(proof.s, Z, proof.c);
        const c = await challenge(this.group, this.params, [p0[1], M, Z, t2, t3]);
        return proof.c.isEqual(c);
    }
}
exports.DLEQVerifier = DLEQVerifier;
class DLEQProver extends DLEQVerifier {
    prove(k, p0, p1, r) {
        return this.prove_batch(k, p0, [p1], r);
    }
    randomScalar() {
        return this.group.randomScalar();
    }
    // prove_batch implements the GenerateProof function
    // from https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-voprf-21#name-discrete-logarithm-equivale
    // The argument p0 corresponds to the elements A, B, and the argument p1s
    // corresponds to the arrays of elements C and D from the specification.
    async prove_batch(key, p0, p1s, r) {
        const rnd = r ? r : await this.randomScalar();
        const { M, Z } = await computeComposites(this.params, p0[1], p1s, key, this.crypto);
        const t2 = p0[0].mul(rnd);
        const t3 = M.mul(rnd);
        const c = await challenge(this.group, this.params, [p0[1], M, Z, t2, t3]);
        const s = rnd.sub(c.mul(key));
        return new DLEQProof(c, s);
    }
}
exports.DLEQProver = DLEQProver;
//# sourceMappingURL=dleq.js.map