"use strict";
// Copyright (c) 2021 Cloudflare, Inc. and contributors.
// Copyright (c) 2021 Cloudflare, Inc.
// Licensed under the BSD-3-Clause license found in the LICENSE file or
// at https://opensource.org/licenses/BSD-3-Clause
Object.defineProperty(exports, "__esModule", { value: true });
exports.getKeySizes = getKeySizes;
exports.validatePrivateKey = validatePrivateKey;
exports.validatePublicKey = validatePublicKey;
exports.randomPrivateKey = randomPrivateKey;
exports.derivePrivateKey = derivePrivateKey;
exports.generatePublicKey = generatePublicKey;
exports.generateKeyPair = generateKeyPair;
exports.deriveKeyPair = deriveKeyPair;
const oprf_js_1 = require("./oprf.js");
const util_js_1 = require("./util.js");
const cryptoImpl_js_1 = require("./cryptoImpl.js");
function getKeySizes(id, ...arg) {
    const gg = (0, cryptoImpl_js_1.getSuiteGroup)(id, arg);
    return { Nsk: gg.scalarSize(), Npk: gg.eltSize(true) };
}
function validatePrivateKey(id, privateKey, ...arg) {
    try {
        const gg = (0, cryptoImpl_js_1.getSuiteGroup)(id, arg);
        const s = gg.desScalar(privateKey);
        return !s.isZero();
    }
    catch (_) {
        return false;
    }
}
function validatePublicKey(id, publicKey, ...arg) {
    try {
        const gg = (0, cryptoImpl_js_1.getSuiteGroup)(id, arg);
        const P = gg.desElt(publicKey);
        return !P.isIdentity();
    }
    catch (_) {
        return false;
    }
}
async function randomPrivateKey(id, ...arg) {
    let priv;
    do {
        const gg = (0, cryptoImpl_js_1.getSuiteGroup)(id, arg);
        priv = await gg.randomScalar();
    } while (priv.isZero());
    return priv.serialize();
}
async function derivePrivateKey(mode, id, seed, info, ...arg) {
    const gg = (0, cryptoImpl_js_1.getSuiteGroup)(id, arg);
    const deriveInput = (0, util_js_1.joinAll)([seed, ...(0, util_js_1.toU16LenPrefix)(info)]);
    let counter = 0;
    let priv;
    do {
        if (counter > 255) {
            throw new Error('DeriveKeyPairError');
        }
        const hashInput = (0, util_js_1.joinAll)([deriveInput, Uint8Array.from([counter])]);
        priv = await gg.hashToScalar(hashInput, oprf_js_1.Oprf.getDST(mode, id, oprf_js_1.Oprf.LABELS.DeriveKeyPairDST));
        counter++;
    } while (priv.isZero());
    return priv.serialize();
}
function generatePublicKey(id, privateKey, ...arg) {
    const gg = (0, cryptoImpl_js_1.getSuiteGroup)(id, arg);
    const priv = gg.desScalar(privateKey);
    const pub = gg.mulGen(priv);
    return pub.serialize(true);
}
async function generateKeyPair(id, ...arg) {
    const privateKey = await randomPrivateKey(id, ...arg);
    const publicKey = generatePublicKey(id, privateKey, ...arg);
    return { privateKey, publicKey };
}
async function deriveKeyPair(mode, id, seed, info, ...arg) {
    const privateKey = await derivePrivateKey(mode, id, seed, info, ...arg);
    const publicKey = generatePublicKey(id, privateKey, ...arg);
    return { privateKey, publicKey };
}
//# sourceMappingURL=keys.js.map