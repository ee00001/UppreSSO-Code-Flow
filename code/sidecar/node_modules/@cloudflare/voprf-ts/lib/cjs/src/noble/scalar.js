"use strict";
// Copyright (c) 2021 Cloudflare, Inc. and contributors.
// Copyright (c) 2021 Cloudflare, Inc.
// Licensed under the BSD-3-Clause license found in the LICENSE file or
// at https://opensource.org/licenses/BSD-3-Clause
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScalarNb = void 0;
const hash_to_curve_1 = require("@noble/curves/abstract/hash-to-curve");
const util_js_1 = require("../util.js");
class ScalarNb {
    constructor(g, k) {
        this.g = g;
        this.field = this.g.params.scalar.field;
        this.k = this.field.create(k);
    }
    static create(g) {
        return new ScalarNb(g, BigInt(0));
    }
    isEqual(s) {
        (0, util_js_1.compat)(this, s);
        return this.k === s.k;
    }
    isZero() {
        return this.k === BigInt(0);
    }
    add(s) {
        (0, util_js_1.compat)(this, s);
        return new ScalarNb(this.g, this.field.add(this.k, s.k));
    }
    sub(s) {
        (0, util_js_1.compat)(this, s);
        return new ScalarNb(this.g, this.field.sub(this.k, s.k));
    }
    mul(s) {
        (0, util_js_1.compat)(this, s);
        return new ScalarNb(this.g, this.field.mul(this.k, s.k));
    }
    inv() {
        return new ScalarNb(this.g, this.field.inv(this.k));
    }
    serialize() {
        return this.field.toBytes(this.k);
    }
    static size(g) {
        return g.params.scalar.size;
    }
    static deserialize(g, bytes) {
        (0, util_js_1.checkSize)(bytes, ScalarNb, g);
        const array = bytes.subarray(0, g.params.scalar.size);
        const k = g.bytesToNumber(array);
        if (k >= g.params.scalar.field.ORDER) {
            throw (0, util_js_1.errDeserialization)(ScalarNb);
        }
        return new ScalarNb(g, k);
    }
    static hash(g, msg, dst) {
        const { scalar, hash } = g.params;
        if (scalar.hash.type === 'hash_to_field') {
            const [[k]] = (0, hash_to_curve_1.hash_to_field)(msg, 1, {
                ...{ hash: hash.fn },
                ...scalar.hash.params,
                DST: dst,
                m: 1
            });
            return new ScalarNb(g, k);
        }
        else {
            const uniform = scalar.hash.type === 'xmd'
                ? (0, hash_to_curve_1.expand_message_xmd)(msg, dst, hash.size, hash.fn)
                : (0, hash_to_curve_1.expand_message_xof)(msg, dst, hash.size, scalar.hash.k, hash.fn);
            const k1 = scalar.field.create(g.bytesToNumber(uniform));
            return new ScalarNb(g, k1);
        }
    }
}
exports.ScalarNb = ScalarNb;
//# sourceMappingURL=scalar.js.map