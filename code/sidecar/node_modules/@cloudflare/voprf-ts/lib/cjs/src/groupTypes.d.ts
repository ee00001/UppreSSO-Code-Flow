export declare const GROUP: {
    readonly P256: "P-256";
    readonly P384: "P-384";
    readonly P521: "P-521";
    readonly RISTRETTO255: "ristretto255";
    readonly DECAF448: "decaf448";
};
export type GroupID = (typeof GROUP)[keyof typeof GROUP];
export declare function errBadGroup(X: string): Error;
export interface Scalar {
    g: Group;
    isEqual(s: Scalar): boolean;
    isZero(): boolean;
    add(s: Scalar): Scalar;
    sub(s: Scalar): Scalar;
    mul(s: Scalar): Scalar;
    inv(): Scalar;
    serialize(): Uint8Array;
}
export interface Elt {
    g: Group;
    isIdentity(): boolean;
    isEqual(a: Elt): boolean;
    neg(): Elt;
    add(a: Elt): Elt;
    mul(s: Scalar): Elt;
    mul2(k1: Scalar, a: Elt, k2: Scalar): Elt;
    serialize(compressed?: boolean): Uint8Array;
}
export interface Deserializer<T> {
    size(compressed?: boolean): number;
    deserialize(b: Uint8Array): T;
}
export interface SerializationHelpers {
    desElt(bytes: Uint8Array): Elt;
    desScalar(bytes: Uint8Array): Scalar;
    eltDes: Deserializer<Elt>;
    scalarDes: Deserializer<Scalar>;
    eltSize(compressed?: boolean): number;
    scalarSize(): number;
}
export interface Group extends SerializationHelpers {
    id: GroupID;
    newScalar(): Scalar;
    newElt(): Elt;
    identity(): Elt;
    generator(): Elt;
    mulGen(s: Scalar): Elt;
    randomScalar(): Promise<Scalar>;
    hashToGroup(msg: Uint8Array, dst: Uint8Array): Promise<Elt>;
    hashToScalar(msg: Uint8Array, dst: Uint8Array): Promise<Scalar>;
}
export interface GroupCons {
    get(id: GroupID): Group;
    supportedGroups: Array<GroupID>;
}
export type GroupCache = Partial<Record<GroupID, Group>>;
//# sourceMappingURL=groupTypes.d.ts.map