"use strict";
// Copyright (c) 2021 Cloudflare, Inc. and contributors.
// Copyright (c) 2021 Cloudflare, Inc.
// Licensed under the BSD-3-Clause license found in the LICENSE file or
// at https://opensource.org/licenses/BSD-3-Clause
Object.defineProperty(exports, "__esModule", { value: true });
exports.FinalizeData = exports.EvaluationRequest = exports.Evaluation = exports.Oprf = void 0;
exports.getOprfParams = getOprfParams;
exports.getSupportedSuites = getSupportedSuites;
const dleq_js_1 = require("./dleq.js");
const groupTypes_js_1 = require("./groupTypes.js");
const util_js_1 = require("./util.js");
const consts_js_1 = require("./consts.js");
const cryptoImpl_js_1 = require("./cryptoImpl.js");
function assertNever(name, x) {
    throw new Error(`unexpected ${name} identifier: ${x}`);
}
function getOprfParams(id) {
    switch (id) {
        case Oprf.Suite.P256_SHA256:
            return [Oprf.Suite.P256_SHA256, groupTypes_js_1.GROUP.P256, 'SHA-256', 32];
        case Oprf.Suite.P384_SHA384:
            return [Oprf.Suite.P384_SHA384, groupTypes_js_1.GROUP.P384, 'SHA-384', 48];
        case Oprf.Suite.P521_SHA512:
            return [Oprf.Suite.P521_SHA512, groupTypes_js_1.GROUP.P521, 'SHA-512', 64];
        case Oprf.Suite.RISTRETTO255_SHA512:
            return [Oprf.Suite.RISTRETTO255_SHA512, groupTypes_js_1.GROUP.RISTRETTO255, 'SHA-512', 64];
        case Oprf.Suite.DECAF448_SHAKE256:
            return [Oprf.Suite.DECAF448_SHAKE256, groupTypes_js_1.GROUP.DECAF448, 'SHAKE256', 64];
        default:
            assertNever('Oprf.Suite', id);
    }
}
// testing helper
function getSupportedSuites(g) {
    return Object.values(Oprf.Suite).filter((v) => g.supportedGroups.includes(getOprfParams(v)[1]));
}
class Oprf {
    static set Crypto(provider) {
        (0, cryptoImpl_js_1.setCryptoProvider)(provider);
    }
    static get Crypto() {
        return (0, cryptoImpl_js_1.getCryptoProvider)();
    }
    static validateMode(m) {
        switch (m) {
            case Oprf.Mode.OPRF:
            case Oprf.Mode.VOPRF:
            case Oprf.Mode.POPRF:
                return m;
            default:
                assertNever('Oprf.Mode', m);
        }
    }
    static getGroup(suite, ...arg) {
        return (0, cryptoImpl_js_1.getSuiteGroup)(suite, arg);
    }
    static getHash(suite) {
        return getOprfParams(suite)[2];
    }
    static getOprfSize(suite) {
        return getOprfParams(suite)[3];
    }
    static getDST(mode, suite, name) {
        const m = Oprf.validateMode(mode);
        const te = new TextEncoder();
        return (0, util_js_1.joinAll)([
            te.encode(name + Oprf.LABELS.Version),
            Uint8Array.of(m),
            te.encode('-' + suite)
        ]);
    }
    constructor(mode, suite, ...arg) {
        const [ID, gid, hash] = getOprfParams(suite);
        this.crypto = (0, cryptoImpl_js_1.getCrypto)(arg);
        this.group = this.crypto.Group.get(gid);
        this.suite = ID;
        this.hashID = hash;
        this.mode = Oprf.validateMode(mode);
    }
    getDLEQParams() {
        const EMPTY_DST = '';
        return { group: this.group.id, hash: this.hashID, dst: this.getDST(EMPTY_DST) };
    }
    getDST(name) {
        return Oprf.getDST(this.mode, this.suite, name);
    }
    async coreFinalize(input, issuedElement, info) {
        let hasInfo = [];
        if (this.mode === Oprf.Mode.POPRF) {
            hasInfo = (0, util_js_1.toU16LenPrefix)(info);
        }
        const hashInput = (0, util_js_1.joinAll)([
            ...(0, util_js_1.toU16LenPrefix)(input),
            ...hasInfo,
            ...(0, util_js_1.toU16LenPrefix)(issuedElement),
            new TextEncoder().encode(Oprf.LABELS.FinalizeDST)
        ]);
        return await this.crypto.hash(this.hashID, hashInput);
    }
    scalarFromInfo(info) {
        if (info.length >= 1 << 16) {
            throw new Error('invalid info length');
        }
        const te = new TextEncoder();
        const framedInfo = (0, util_js_1.joinAll)([te.encode(Oprf.LABELS.InfoLabel), ...(0, util_js_1.toU16LenPrefix)(info)]);
        return this.group.hashToScalar(framedInfo, this.getDST(Oprf.LABELS.HashToScalarDST));
    }
}
exports.Oprf = Oprf;
Oprf.Mode = consts_js_1.MODE;
Oprf.Suite = consts_js_1.SUITE;
Oprf.LABELS = consts_js_1.LABELS;
class Evaluation {
    constructor(mode, evaluated, proof) {
        this.mode = mode;
        this.evaluated = evaluated;
        this.proof = proof;
    }
    serialize() {
        let proofBytes = new Uint8Array();
        if (this.proof && (this.mode == Oprf.Mode.VOPRF || this.mode == Oprf.Mode.POPRF)) {
            proofBytes = this.proof.serialize();
        }
        return (0, util_js_1.joinAll)([
            ...(0, util_js_1.toU16LenPrefixClass)(this.evaluated),
            Uint8Array.from([this.mode]),
            proofBytes
        ]);
    }
    isEqual(e) {
        if (this.mode !== e.mode || (this.proof && !e.proof) || (!this.proof && e.proof)) {
            return false;
        }
        let res = this.evaluated.every((x, i) => x.isEqual(e.evaluated[i]));
        if (this.proof && e.proof) {
            res && (res = this.proof.isEqual(e.proof));
        }
        return res;
    }
    static deserialize(suite, bytes, ...arg) {
        const group = (0, cryptoImpl_js_1.getSuiteGroup)(suite, arg);
        const { head: evalList, tail } = (0, util_js_1.fromU16LenPrefixDes)(group.eltDes, bytes);
        let proof;
        const proofSize = dleq_js_1.DLEQProof.size(group);
        const proofBytes = tail.subarray(1, 1 + proofSize);
        const mode = tail[0];
        switch (mode) {
            case Oprf.Mode.OPRF: // no proof exists.
                break;
            case Oprf.Mode.VOPRF:
            case Oprf.Mode.POPRF:
                proof = dleq_js_1.DLEQProof.deserialize(group.id, proofBytes, ...arg);
                break;
            default:
                assertNever('Oprf.Mode', mode);
        }
        return new Evaluation(mode, evalList, proof);
    }
}
exports.Evaluation = Evaluation;
class EvaluationRequest {
    constructor(blinded) {
        this.blinded = blinded;
    }
    serialize() {
        return (0, util_js_1.joinAll)((0, util_js_1.toU16LenPrefixClass)(this.blinded));
    }
    isEqual(e) {
        return this.blinded.every((x, i) => x.isEqual(e.blinded[i]));
    }
    static deserialize(suite, bytes, ...arg) {
        const g = (0, cryptoImpl_js_1.getSuiteGroup)(suite, arg);
        const { head: blindedList } = (0, util_js_1.fromU16LenPrefixDes)(g.eltDes, bytes);
        return new EvaluationRequest(blindedList);
    }
}
exports.EvaluationRequest = EvaluationRequest;
class FinalizeData {
    constructor(inputs, blinds, evalReq) {
        this.inputs = inputs;
        this.blinds = blinds;
        this.evalReq = evalReq;
    }
    serialize() {
        return (0, util_js_1.joinAll)([
            ...(0, util_js_1.toU16LenPrefixUint8Array)(this.inputs),
            ...(0, util_js_1.toU16LenPrefixClass)(this.blinds),
            this.evalReq.serialize()
        ]);
    }
    isEqual(f) {
        return (this.inputs.every((x, i) => x.toString() === f.inputs[i].toString()) &&
            this.blinds.every((x, i) => x.isEqual(f.blinds[i])) &&
            this.evalReq.isEqual(f.evalReq));
    }
    static deserialize(suite, bytes, ...arg) {
        const g = (0, cryptoImpl_js_1.getSuiteGroup)(suite, arg);
        const { head: inputs, tail: t0 } = (0, util_js_1.fromU16LenPrefixUint8Array)(bytes);
        const { head: blinds, tail: t1 } = (0, util_js_1.fromU16LenPrefixDes)(g.scalarDes, t0);
        const evalReq = EvaluationRequest.deserialize(suite, t1, ...arg);
        return new FinalizeData(inputs, blinds, evalReq);
    }
}
exports.FinalizeData = FinalizeData;
//# sourceMappingURL=oprf.js.map