diff --git a/node_modules/@cloudflare/privacypass-ts/lib/src/arbitrary_batched_token.js b/node_modules/@cloudflare/privacypass-ts/lib/src/arbitrary_batched_token.js
index 385c33d..ea2d59a 100644
--- a/node_modules/@cloudflare/privacypass-ts/lib/src/arbitrary_batched_token.js
+++ b/node_modules/@cloudflare/privacypass-ts/lib/src/arbitrary_batched_token.js
@@ -54,19 +54,29 @@ export class BatchedTokenRequest {
         this.tokenRequests = tokenRequests;
     }
     static deserialize(bytes) {
+        const toHex = (u8, n = 24) =>
+            Array.from(u8.slice(0, Math.min(n, u8.length)))
+                .map(b => b.toString(16).padStart(2, '0'))
+                .join(' ');
+
         let offset = 0;
-        const input = new DataView(bytes.buffer);
-        const { value: length, usize } = varint.read(input, offset);
+        const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
+        const { value: length, usize } = varint.read(dv, offset);
+
         offset += usize;
         if (length + offset !== bytes.length) {
             throw new Error('provided bytes does not match its encoded length');
         }
+
         const batchedTokenRequests = [];
+        let idx = 0;
         while (offset < bytes.length) {
-            const tokenTypeEntry = tokenRequestToTokenTypeEntry(bytes);
+            const view = new Uint8Array(bytes.buffer, bytes.byteOffset + offset, bytes.length - offset);
+
+            const tokenTypeEntry = tokenRequestToTokenTypeEntry(view);
             const len = tokenEntryToSerializedLength(tokenTypeEntry);
-            const b = new Uint8Array(input.buffer.slice(offset, offset + len));
-            offset += len;
+            const b = new Uint8Array(bytes.buffer, bytes.byteOffset + offset, len);
+            offset += len + 3;
             batchedTokenRequests.push(TokenRequest.deserialize(b));
         }
         return new BatchedTokenRequest(batchedTokenRequests);
diff --git a/node_modules/@cloudflare/privacypass-ts/lib/src/index.js b/node_modules/@cloudflare/privacypass-ts/lib/src/index.js
index 401d2e1..f66a090 100644
--- a/node_modules/@cloudflare/privacypass-ts/lib/src/index.js
+++ b/node_modules/@cloudflare/privacypass-ts/lib/src/index.js
@@ -82,7 +82,7 @@ export function tokenEntryToSerializedLength(tokenType) {
 }
 export function tokenRequestToTokenTypeEntry(bytes) {
     // All token requests have a 2-byte value at the beginning of the token describing TokenTypeEntry.
-    const input = new DataView(bytes.buffer);
+    const input = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
     const type = input.getUint16(0);
     const tokenType = Object.values(TOKEN_TYPES).find((t) => t.value === type);
     if (tokenType === undefined) {
diff --git a/node_modules/@cloudflare/privacypass-ts/lib/src/pub_verif_token.js b/node_modules/@cloudflare/privacypass-ts/lib/src/pub_verif_token.js
index ed2396c..759694e 100644
--- a/node_modules/@cloudflare/privacypass-ts/lib/src/pub_verif_token.js
+++ b/node_modules/@cloudflare/privacypass-ts/lib/src/pub_verif_token.js
@@ -87,16 +87,16 @@ export class TokenRequest {
     }
     static deserialize(tokenType, bytes) {
         let offset = 0;
-        const input = new DataView(bytes.buffer);
-        const type = input.getUint16(offset);
+        const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
+        const type = dv.getUint16(offset);
         offset += 2;
         if (type !== tokenType.value) {
             throw new Error('mismatch of token type');
         }
-        const tokenKeyId = input.getUint8(offset);
+        const tokenKeyId = dv.getUint8(offset);
         offset += 1;
         const len = tokenType.Nk;
-        const blindedMsg = new Uint8Array(input.buffer.slice(offset, offset + len));
+        const blindedMsg = new Uint8Array(bytes.buffer, bytes.byteOffset + offset, len);
         offset += len;
         return new TokenRequest(tokenKeyId, blindedMsg, tokenType);
     }
